#!/usr/bin/env python
#
# LPUnit test preprocessor 
#

import sys, string
from copy import deepcopy

macros = { 'pass': [ 'lpunit::Assert(true);' ],
           'fail': [ 'lpunit::Assert(false);' ],
           'assert': [ 'LPUNIT_ASSERT(({1}), {s1});' ],
           'equal': [ 'LPUNIT_EQUAL(({1}), ({2}), {s1}, {s2});' ],
           'notequal': [ 'LPUNIT_NOTEQUAL(({1}), ({2}), {s1}, {2});' ],
           'approx': [ 'LPUNIT_APPROX(({1}),({2}),{s1}, {s2},({3}));' ],
           'notapprox': [ 'LPUNIT_NOTAPPROX(({1}),({2}),{s1},{s2},({3}));' ],
           'message': [ 'std::cout << "{*}" << std::endl;\n' ],
           'warning': [ 'std::cout << "[Warning] " << "{*}" << std::endl;\n' ],
         }

class TestSuite:

  def __init__(self):  
      self.header, self.tests, self.metadata = [], [], {}
      self.beforetest, self.aftertest = [], []
      
  def ReadFile(self, f):
      self.header, self.tests, self.metadata = [], [], {}
      self.beforetest, self.aftertest = [], []
      inBlock, thisBlock = False, []
      thisTestName = ''
      self.metadata['ignoretests'] = []
      for line in f:
          ls = line.strip()
          if ls == '' or ls.startswith('//'): continue
          if ls.startswith('@'):
             lspl = ls.split()
             tagname, value = lspl[0][1:], string.join(lspl[1:], ' ')
             if tagname == 'testsuite': self.metadata['suitename'] = value.strip() 
             elif tagname == 'ignore': self.metadata['ignoretests'].append(thisTestName)
             elif tagname == 'test': 
                inBlock, blockName = True, 'test'
                thisBlock, thisTestName = [], value.strip()
             elif tagname == 'beforetest':
                inBlock, blockName = True, 'beforetest'
                thisBlock = []
             elif tagname == 'aftertest':
                inBlock, blockName = True, 'aftertest'
                thisBlock = []
             elif tagname == 'end': 
                if inBlock and blockName == 'test': 
                   self.tests.append((thisTestName, thisBlock))
                elif inBlock and blockName == 'beforetest':
                   self.beforetest = thisBlock
                elif inBlock and blockName == 'aftertest':
                   self.aftertest = thisBlock
                inBlock = False
             elif macros.has_key(tagname):
                lines = self.ExpandMacro(tagname, self.SplitCArguments(value))
                if inBlock: 
                   for x in lines: thisBlock.append(x.rstrip())
                else: 
                   for x in lines: self.header.append(x.rstrip())
             else:
                print "[Error] Unknown tag, @%s" % tagname
                sys.exit(1)
          else:
             if inBlock: thisBlock.append(line.rstrip())
             else: self.header.append(line.rstrip()) 

  def SplitCArguments(self, rhs):
      openprot = False
      args, p0, commas = [], 0, []
      for i in range(0, len(rhs)):
          c = rhs[i] 
          if c == '(' or c == '[': openprot = True
          elif c == ')' or c == ']': openprot = False
          elif c == '\"' or c == '\'': openprot = (not openprot)
          if c == ',' and not openprot: commas.append(i)
      for pos in commas:
          args.append(rhs[p0:pos])
          p0 = pos+1
      args.append(rhs[p0:])
      return [x.strip() for x in args]

  def ExpandMacro(self, tagname, args):
      macrocode = deepcopy(macros[tagname])
      i = 1
      for arg in args:
          for j in range(0, len(macrocode)):
              macrocode[j] = macrocode[j].replace('{%d}' % i, arg)
              macrocode[j] = macrocode[j].replace('{s%d}' % i, "\""+arg.replace("\"", "\\\"")+"\"")
          i += 1 
      values = string.join(args, ' ')
      for j in range(0, len(macrocode)): macrocode[j] = macrocode[j].replace('{*}', values)
      return macrocode 

  def Render(self, f):
      f.write('//\n// This C++ file was automatically generated by lpmaketest.py\n//\n')
      f.write('// Test suite name: %s\n//\n\n' % self.metadata['suitename'])
      for line in self.header: f.write(line+'\n')
      f.write('\n#include <lpunit/testsuite.h>\n')
      f.write('\n#include <lpunit/macros.h>\n')
      f.write('\n#include <cmath>\n')
      f.write('using namespace lpunit;\n')
      f.write('\n')
      hasSetup, hasTeardown = False, False
      if len(self.beforetest) > 0:
         f.write('// Setup function\nvoid Setup()\n')
         for line in self.beforetest: f.write(line+'\n')
         hasSetup = True
      if len(self.aftertest) > 0:
         f.write('\n// Teardown function\nvoid Teardown()\n')
         for line in self.aftertest: f.write(line+'\n')
         hasTeardown = True
         f.write('\n')
      nt = 1
      for test in self.tests:
          if test[0] not in self.metadata['ignoretests']:
             f.write('// Test name: %s\n' % test[0])
             f.write('void Test%d()\n' % nt)
             for line in test[1]: f.write(line+'\n')
             f.write('\n')
             nt += 1
      f.write('// Main program\n')
      f.write('int main()\n{\n')
      f.write(' TestSuite ts(\"%s\");\n' % self.metadata['suitename'])
      if hasSetup: f.write(' ts.SetTestsSetup(Setup);\n')
      if hasTeardown: f.write(' ts.SetTestsTeardown(Teardown);\n')
      nt = 1
      for test in self.tests:
          if test[0] not in self.metadata['ignoretests']:
             f.write(' ts.Register(new SimpleTest(\"%s\", Test%d));\n' % (test[0], nt))
             nt += 1
      f.write(' return ts.PerformAllTests();\n')
      f.write('}\n\n')

#
#
#

t = TestSuite()
ff = sys.stdin
if len(sys.argv) > 1 and sys.argv[1] != '-': ff = file(sys.argv[1], 'r')
t.ReadFile(ff)
gg = sys.stdout
if len(sys.argv) > 2 and sys.argv[2] != '-': gg = file(sys.argv[2], 'w')
t.Render(gg)

